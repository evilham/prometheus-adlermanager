"""
This type stub file was generated by pyright.
"""

from typing import (
    Any,
    AnyStr,
    Callable,
    Dict,
    Generator,
    Iterable,
    List,
    NoReturn,
    Optional,
    Sequence,
    Type,
)

from zope.interface import Interface, implementer

import attr
from twisted.internet.defer import Deferred, inlineCallbacks
from twisted.python.components import Componentized
from twisted.web.iweb import IRenderable, IRequest
from twisted.web.resource import Resource
from twisted.web.template import Element, Tag

from ._app import KleinRenderable
from ._decorators import bindable
from .interfaces import (
    IDependencyInjector,
    IRequestLifecycle,
    IRequiredParameter,
    ISession,
    ValidationError,
)

class CrossSiteRequestForgery(Resource):
    """
    Cross site request forgery detected.  Request aborted.
    """

    def __init__(self, message: str) -> None: ...
    def render(self, request: IRequest) -> bytes:
        """
        For all HTTP methods, return a 403.
        """
        ...

CSRF_PROTECTION = ...

def textConverter(value: AnyStr) -> str:
    """
    Converter for form values (which may be any type of string) into text.
    """
    ...

class IParsedJSONBody(Interface):
    """
    Marker interface for the dict parsed from the request body's JSON contents.
    """

    ...

@implementer(IRequiredParameter)
@attr.s(auto_attribs=True, frozen=True)
class Field:
    """
    A L{Field} is a static part of a L{Form}.

    @ivar converter: The converter.
    """

    converter: Callable[[AnyStr], Any]
    formInputType: str
    pythonArgumentName: Optional[str] = ...
    formFieldName: Optional[str] = ...
    formLabel: Optional[str] = ...
    default: Optional[Any] = ...
    required: bool = ...
    noLabel: bool = ...
    value: str = ...
    error: Optional[ValidationError] = ...
    def registerInjector(
        self,
        injectionComponents: Componentized,
        parameterName: str,
        requestLifecycle: IRequestLifecycle,
    ) -> IDependencyInjector:
        """
        Register this form field as a dependency injector.
        """
        ...
    def maybeNamed(self, name: str) -> Field:
        """
        Create a new L{Field} like this one, but with all the name default
        values filled in.

        @param name: the name.
        """
        ...
    def asTags(self) -> Iterable[Tag]:
        """
        Convert this L{Field} into some stuff that can be rendered in a
        L{twisted.web.template}.

        @return: A new set of tags to include in a template.
        """
        ...
    def extractValue(self, request: IRequest) -> Any:
        """
        Extract a value from the request.

        In the case of key/value form posts, this attempts to reliably make the
        value into str.  In the case of a JSON post, however, it will simply
        extract the value from the top-level dictionary, which means it could
        be any arrangement of JSON-serializiable objects.
        """
        ...
    def validateValue(self, value: Any) -> Any:
        """
        Validate the given text and return a converted Python object to use, or
        fail with L{ValidationError}.

        @param value: The value that was extracted by L{Field.extractValue}.

        @return: The converted value.
        """
        ...
    @classmethod
    def text(cls, **kw: Any) -> Field:
        """
        Shorthand for a form field that contains a short string, and will be
        rendered as a plain <input>.
        """
        ...
    @classmethod
    def password(cls, **kw: Any) -> Field:
        """
        Shorthand for a form field that, like L{text}, contains a short string,
        but should be obscured when typed (and, to the extent possible,
        obscured in other sensitive contexts, such as logging.)
        """
        ...
    @classmethod
    def hidden(cls, name: str, value: str, **kw: Any) -> Field:
        """
        Shorthand for a hidden field.
        """
        ...
    @classmethod
    def number(
        cls,
        minimum: Optional[int] = ...,
        maximum: Optional[int] = ...,
        kind: Type = ...,
        **kw: Any,
    ) -> Field:
        """
        An integer within the range [minimum, maximum].
        """
        ...
    @classmethod
    def submit(cls, value: str) -> Field:
        """
        A field representing a submit button, with a value (displayed on the
        button).
        """
        ...

@implementer(IRenderable)
@attr.s(auto_attribs=True)
class RenderableForm:
    """
    An L{IRenderable} representing a renderable form.

    @ivar prevalidationValues: a L{dict} mapping {L{Field}: L{list} of
        L{str}}, representing the value that each field received as part of
        the request.

    @ivar validationErrors: a L{dict} mapping {L{Field}: L{ValidationError}}
    """

    _form: IForm
    _session: ISession
    _action: str
    _method: str
    _enctype: str
    _encoding: str
    prevalidationValues: Dict[Field, Optional[str]] = ...
    validationErrors: Dict[Field, ValidationError] = ...
    ENCTYPE_FORM_DATA = ...
    ENCTYPE_URL_ENCODED = ...
    def lookupRenderMethod(self, name: str) -> NoReturn:
        """
        Form renderers don't supply any render methods, so this just always
        raises L{MissingRenderMethod}.
        """
        ...
    def render(self, request: IRequest) -> Tag:
        """
        Render this form to the given request.
        """
        ...
    def glue(self) -> List[Tag]:
        """
        Provide any glue necessary to render this form; this must be dropped
        into the template within the C{<form>} tag.

        Presently, this glue includes only the CSRF token argument, but Klein
        reserves the right to add arbitrary HTML here.  This should not create
        any user-visible content, however.

        @return: some HTML elements in the form of renderable objects for
            L{twisted.web.template}
        """
        ...

@bindable
def defaultValidationFailureHandler(
    instance: Optional[object], request: IRequest, fieldValues: FieldValues
) -> Element:
    """
    This is the default validation failure handler, which will be used by form
    handlers (i.e. any routes which use L{klein.Requirer} to require a field)
    in the case of any input validation failure when no other validation
    failure handler is registered via L{Form.onValidationFailureFor}.

    Its behavior is to simply return an HTML rendering of the form object,
    which includes inline information about fields which failed to validate.

    @param instance: The instance associated with the router that the form
        handler was handled on.
    @param request: The request including the form submission.
    @return: Any object acceptable from a Klein route.
    """
    ...

_requirerFunctionWithForm = Any
_routeCallable = Any

class IProtoForm(Interface):
    """
    Marker interface for L{ProtoForm}.
    """

    fields: Sequence[Field] = ...
    def addField(field: Field) -> FieldInjector:
        """
        Add the given field to the form ultimately created here.
        """
        ...

class IForm(Interface):
    """
    Marker interface for form attached to dependency injection components.
    """

    fields: Sequence[Field] = ...
    def populateRequestValues(
        injectionComponents: Componentized, instance: Any, request: IRequest
    ) -> Deferred:
        """
        Extract the values present in this request and populate a
        L{FieldValues} object.
        """
        ...

@implementer(IProtoForm)
@attr.s(auto_attribs=True)
class ProtoForm:
    """
    Form-builder.
    """

    _componentized: Componentized
    _lifecycle: IRequestLifecycle
    fields: List[Field] = ...
    @classmethod
    def fromComponentized(cls, componentized: Componentized) -> ProtoForm:
        """
        Create a ProtoForm from a componentized object.
        """
        ...
    def addField(self, field: Field) -> FieldInjector: ...

class IFieldValues(Interface):
    """
    Marker interface for parsed fields.
    """

    form: IForm = ...
    arguments: Dict[str, Any] = ...
    prevalidationValues: Dict[Field, Optional[str]] = ...
    validationErrors: Dict[Field, ValidationError] = ...
    def validate(instance: Any, request: IRequest) -> Deferred:
        """
        If any validation errors have occurred, raise a relevant exception.
        """
        ...

@implementer(IFieldValues)
@attr.s(auto_attribs=True)
class FieldValues:
    """
    Reified post-parsing values for HTTP form submission.
    """

    form: Form
    arguments: Dict[str, Any]
    prevalidationValues: Dict[Field, Optional[str]]
    validationErrors: Dict[Field, ValidationError]
    _injectionComponents: Componentized
    @inlineCallbacks
    def validate(
        self, instance: Any, request: IRequest
    ) -> Generator[Any, object, None]: ...

@implementer(IDependencyInjector)
@attr.s(auto_attribs=True)
class FieldInjector:
    """
    Field injector.
    """

    _componentized: Componentized
    _field: Field
    _lifecycle: IRequestLifecycle
    def injectValue(
        self, instance: Any, request: IRequest, routeParams: Dict[str, Any]
    ) -> Any:
        """
        Inject the given value into the form.
        """
        ...
    def finalize(self) -> None:
        """
        Finalize this ProtoForm into a real form.
        """
        ...

class IValidationFailureHandler(Interface):
    """
    Validation failure handler callable interface.
    """

    def __call__(request: IRequest) -> KleinRenderable:
        """
        Called to handle a validation failure.
        """
        ...

def checkCSRF(request: IRequest) -> None:
    """
    Check the request for cross-site request forgery, raising an EarlyExit if
    it is found.
    """
    ...

@implementer(IForm)
@attr.s(auto_attribs=True, hash=False)
class Form:
    """
    A L{Form} is a collection of fields attached to a function.
    """

    fields: Sequence[Field]
    @staticmethod
    def onValidationFailureFor(
        handler: _requirerFunctionWithForm,
    ) -> Callable[[Callable], Callable]:
        """
        Register a function to be run in the event of a validation failure for
        the input to a particular form handler.

        Generally used like so::

            requirer = Requirer(...)
            @requirer.prerequisite([ISession])
            def procureSession(request):
                return SessionProcurer(...).procureSession(request)
            router = Klein()
            @requirer.require(router.route("/", methods=['POST']),
                              someField=Field.text())
            def formHandler(someField):
                ...
            # Handle input validation failures for handleForm
            @Form.onValidationFailureFor(formHandler)
            def handleValidationFailures(request, fieldValues):
                return "Your inputs didn't validate."

        @see: L{defaultValidationFailureHandler} for a more detailed
            description of the decorated function's expected signature.  The
            additional parameter it is passed is a L{FieldValues} instance.

        @param handler: The form handler - i.e. function decorated by
            L{Form.handler} - for which the decorated function will handle
            validation failures.

        @return: a decorator that decorates a function with the signature
            C{(request, form) -> thing klein can render}.
        """
        ...
    @inlineCallbacks
    def populateRequestValues(
        self, injectionComponents: Componentized, instance: Any, request: IRequest
    ) -> Generator[Any, object, None]: ...
    @classmethod
    def rendererFor(
        cls,
        decoratedFunction: _requirerFunctionWithForm,
        action: str,
        method: str = ...,
        enctype: str = ...,
        encoding: str = ...,
    ) -> RenderableFormParam:
        """
        A form parameter that can render a form declared as a number of fields
        on another route.

        Use like so::

            class MyFormApp:
                router = Klein()
                requirer = Requirer()

                @requirer.require(
                    router.route("/handle-form", methods=["POST"]),
                    name=Field.text(), value=Field.integer(),
                )
                def formRoute(self, name, value):
                    ...

                @requirer.require(
                    router.route("/show-form", methods=["GET"]),
                    form=Form.rendererFor(formRoute)
                )
                def showForm(self, form):
                    return form

        As a L{RenderableForm} provides L{IRenderable}, you may return the
        parameter directly
        """
        ...

@implementer(IRequiredParameter, IDependencyInjector)
@attr.s(auto_attribs=True)
class RenderableFormParam:
    """
    A L{RenderableFormParam} implements L{IRequiredParameter} and
    L{IDependencyInjector} to provide a L{RenderableForm} to your route.
    """

    _form: IForm
    _action: str
    _method: str
    _enctype: str
    _encoding: str
    def registerInjector(
        self,
        injectionComponents: Componentized,
        parameterName: str,
        requestLifecycle: IRequestLifecycle,
    ) -> RenderableFormParam: ...
    def injectValue(
        self, instance: Any, request: IRequest, routeParams: Dict[str, Any]
    ) -> RenderableForm:
        """
        Create the renderable form from the request.
        """
        ...
    def finalize(self) -> None:
        """
        Nothing to do upon finalization.
        """
        ...
