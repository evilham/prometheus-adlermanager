"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, Optional, Type

from zope.interface import Interface, implementer

import attr
from twisted.internet.defer import inlineCallbacks
from twisted.python.components import Componentized
from twisted.web.iweb import IRequest
from twisted.web.resource import Resource

from .interfaces import (
    IDependencyInjector,
    IRequestLifecycle,
    IRequiredParameter,
    ISessionProcurer,
    ISessionStore,
)

@implementer(ISessionProcurer)
@attr.s(auto_attribs=True)
class SessionProcurer:
    """
    A L{SessionProcurer} procures a session from a request and a store.

    @ivar _store: The session store to procure a session from.
    @ivar _maxAge: The maximum age (in seconds) of the session cookie.
    @ivar _secureCookie: The name of the cookie to use for sessions protected
        with TLS (i.e. HTTPS).
    @ivar _insecureCookie: The name of the cookie to use for sessions I{not}
        protected with TLS (i.e. HTTP).
    @ivar _cookieDomain: If set, the domain name to restrict the session cookie
        to.
    @ivar _cookiePath: If set, the URL path to restrict the session cookie to.
    @ivar _secureTokenHeader: The name of the HTTPS header to try to extract a
        session token from; API clients should use this header, rather than a
        cookie.
    @ivar _insecureTokenHeader: The name of the HTTP header to try to extract a
        session token from; API clients should use this header, rather than a
        cookie.
    @ivar _setCookieOnGET: Automatically request that the session store create
        a session if one is not already associated with the request and the
        request is a GET.
    """

    _store: ISessionStore
    _maxAge: int = ...
    _secureCookie: bytes = ...
    _insecureCookie: bytes = ...
    _cookieDomain: Optional[bytes] = ...
    _cookiePath: bytes = ...
    _secureTokenHeader: bytes = ...
    _insecureTokenHeader: bytes = ...
    _setCookieOnGET: bool = ...
    @inlineCallbacks
    def procureSession(self, request: IRequest, forceInsecure: bool = ...) -> Any: ...

class AuthorizationDenied(Resource):
    def __init__(self, interface: Type[Interface], instance: Any) -> None: ...
    def render(self, request: IRequest) -> bytes: ...

@implementer(IDependencyInjector, IRequiredParameter)
@attr.s(auto_attribs=True)
class Authorization:
    """
    Declare that a C{require}-decorated function requires a certain interface
    be authorized from the session.

    This is a dependency injector used in conjunction with a L{klein.Requirer},
    like so::

        from klein import Requirer, SesssionProcurer
        from klein.interfaces import ISession

        from myapp import ISuperDuperAdmin

        requirer = Requirer()
        procurer = SessionProcurer(store=someSessionStore)
        @requirer.prerequisite(ISession)
        def sessionize(request):
            return procurer.procureSession(request)

        app = Klein()

        @requirer.require(
            app.route("/admin"),
            adminPowers=Authorization(ISuperDuperAdmin)
        )
        def myRoute(adminPowers):
            return 'ok admin: ' + adminPowers.doAdminThing()

    In this example, ISuperDuperAdmin is an interface known to your
    application, and (via authorization plugins depending on your session
    storage backend) to your session store.  It has a doAdminThing method.
    When a user hits /admin in their browser, if they are duly authorized,
    they'll see 'ok admin: ' and whatever the super-secret result of
    doAdminThing is.  If not, by default, they'll simply get an HTTP
    UNAUTHORIZED response that says "myapp.ISuperDuperAdmin DENIED".  (This
    behavior can be customized via the C{whenDenied} parameter to
    L{Authorization}.)

    @ivar _interface: the interface that is required.  a provider of this
        interface is what will be dependency-injected.

    @ivar _required: is this authorization required?  If so (the default),
        don't invoke the application code if it cannot be authorized by the
        procured session, and instead return the object specified by whenDenied
        from the dependency-injection process.  If not, then just pass None if
        it is not on the session.

    @ivar _whenDenied: when this authorization is denied, what object - usually
        an IResource - should be returned to the route decorator that was
        passed to L{Requirer.require}?  Note that this will never be used if
        C{required} is set to C{False}.
    """

    _interface: Type[Interface]
    _required: bool = ...
    _whenDenied: Callable[[Type[Interface], Any], Any] = ...
    def registerInjector(
        self,
        injectionComponents: Componentized,
        parameterName: str,
        lifecycle: IRequestLifecycle,
    ) -> IDependencyInjector:
        """
        Register this authorization to inject a parameter.
        """
        ...
    @inlineCallbacks
    def injectValue(
        self, instance: Any, request: IRequest, routeParams: Dict[str, Any]
    ) -> Any:
        """
        Inject a value by asking the request's session.
        """
        ...
    def finalize(self) -> None:
        """
        Nothing to finalize when registering.
        """
        ...
