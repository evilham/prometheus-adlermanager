import base64
import os
from collections.abc import Generator
from typing import IO, Iterable, Tuple, Union

from zope.interface import Interface

from _typeshed import Incomplete
from twisted.python.compat import cmp as cmp, comparable as comparable
from twisted.python.runtime import platform as platform
from twisted.python.util import FancyEqMixin as FancyEqMixin
from twisted.python.win32 import (
    ERROR_DIRECTORY as ERROR_DIRECTORY,
    ERROR_FILE_NOT_FOUND as ERROR_FILE_NOT_FOUND,
    ERROR_INVALID_NAME as ERROR_INVALID_NAME,
    ERROR_PATH_NOT_FOUND as ERROR_PATH_NOT_FOUND,
    O_BINARY as O_BINARY,
)

islink: Incomplete
randomBytes = os.urandom
armor = base64.urlsafe_b64encode

class IFilePath(Interface):
    sep: Incomplete
    def child(name) -> None: ...
    def open(mode: str = ...) -> None: ...
    def changed() -> None: ...
    def getsize() -> None: ...
    def getModificationTime() -> None: ...
    def getStatusChangeTime() -> None: ...
    def getAccessTime() -> None: ...
    def exists() -> bool: ...
    def isdir() -> bool: ...
    def isfile() -> bool: ...
    def children() -> Iterable[IFilePath]: ...
    def basename() -> None: ...
    def parent() -> IFilePath: ...
    def sibling(name) -> None: ...

class InsecurePath(Exception): ...
class LinkError(Exception): ...

class UnlistableError(OSError):
    originalException: Incomplete
    def __init__(self, originalException: OSError) -> None: ...

class AbstractFilePath:
    def getContent(self) -> bytes: ...
    def parents(self) -> Generator[Incomplete, None, None]: ...
    def children(self) -> Iterable[IFilePath]: ...
    def walk(
        self, descend: Incomplete | None = ...
    ) -> Generator[Incomplete, None, None]: ...
    def sibling(self, path): ...
    def descendant(self, segments): ...
    def segmentsFrom(self, ancestor): ...
    def __hash__(self): ...
    def getmtime(self): ...
    def getatime(self): ...
    def getctime(self): ...

class RWX(FancyEqMixin):
    compareAttributes: Incomplete
    read: Incomplete
    write: Incomplete
    execute: Incomplete
    def __init__(self, readable, writable, executable) -> None: ...
    def shorthand(self): ...

class Permissions(FancyEqMixin):
    compareAttributes: Incomplete
    def __init__(self, statModeInt) -> None: ...
    def shorthand(self): ...

class FilePath(AbstractFilePath):
    path: Union[bytes, str]
    alwaysCreate: Incomplete
    def __init__(self, path: Union[bytes, str], alwaysCreate: bool = ...) -> None: ...
    @property
    def sep(self): ...
    def asBytesMode(self, encoding: Incomplete | None = ...): ...
    def asTextMode(self, encoding: Incomplete | None = ...): ...
    def child(self, path: Union[str, bytes]) -> FilePath: ...
    def preauthChild(self, path): ...
    def childSearchPreauth(self, *paths): ...
    def siblingExtensionSearch(self, *exts) -> FilePath: ...
    def realpath(self): ...
    def siblingExtension(self, ext: Union[str, bytes]) -> FilePath: ...
    def linkTo(self, linkFilePath) -> None: ...
    def open(self, mode: str = ...) -> IO[bytes]: ...
    def restat(self, reraise: bool = ...) -> None: ...
    def changed(self) -> None: ...
    def chmod(self, mode: int) -> None: ...
    def getsize(self): ...
    def getModificationTime(self): ...
    def getStatusChangeTime(self): ...
    def getAccessTime(self): ...
    def getInodeNumber(self): ...
    def getDevice(self): ...
    def getNumberOfHardLinks(self): ...
    def getUserID(self): ...
    def getGroupID(self): ...
    def getPermissions(self): ...
    def exists(self) -> bool: ...
    def isdir(self) -> bool: ...
    def isfile(self) -> bool: ...
    def isBlockDevice(self): ...
    def isSocket(self): ...
    def islink(self): ...
    def isabs(self): ...
    def listdir(self): ...
    def splitext(self) -> Tuple[str, str]: ...
    def touch(self) -> None: ...
    def remove(self) -> None: ...
    def makedirs(self, ignoreExistingDirectory: bool = ...) -> None: ...
    def globChildren(self, pattern): ...
    def basename(self) -> str: ...
    def dirname(self): ...
    def parent(self) -> FilePath: ...
    def setContent(self, content: bytes, ext: bytes = ...) -> None: ...
    def __cmp__(self, other): ...
    def createDirectory(self) -> None: ...
    def requireCreate(self, val: int = ...) -> None: ...
    def create(self) -> IO[bytes]: ...
    def temporarySibling(self, extension: bytes = ...) -> FilePath: ...
    def copyTo(self, destination, followLinks: bool = ...) -> None: ...
    def moveTo(
        self, destination: Union[str, bytes, FilePath], followLinks: bool = ...
    ) -> None: ...
